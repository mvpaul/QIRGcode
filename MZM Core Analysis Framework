import numpy as np
import matplotlib.pyplot as plt
from scipy.special import jv  # Bessel function of the first kind
from scipy.signal import hilbert
import scipy.fft as fft

class MZMAnalyzer:
    """
    Fixed MZM Analysis Framework - Optimized for Visualization
    
    This class implements MZM analysis with proper scaling for clear visualization
    of both time and frequency domain behavior.
    """
    
    def __init__(self, fc_baseband=0, fm=1e9, fs=50e9, duration=10e-9):
        """
        Initialize with baseband analysis for better visualization
        
        Parameters:
        fc_baseband: baseband carrier (0 Hz for baseband analysis)
        fm: modulation frequency spacing (1 GHz)  
        fs: sampling frequency (50 GHz - sufficient for modulation analysis)
        duration: simulation duration (10 ns)
        """
        self.fc_baseband = fc_baseband  # Use baseband for analysis
        self.fm = fm
        self.fs = fs
        self.duration = duration
        
        # Create time array with reasonable number of points
        self.num_samples = int(fs * duration)
        if self.num_samples > 10000:  # Limit for visualization
            self.num_samples = 10000
            self.fs = self.num_samples / duration
            
        self.t = np.linspace(0, duration, self.num_samples)
        
        # Angular frequencies
        self.omega_c = 2 * np.pi * fc_baseband
        self.omega_m = 2 * np.pi * fm
        
        print(f"=== MZM Analyzer Initialized (Fixed Version) ===")
        print(f"Baseband carrier: {fc_baseband} Hz (for visualization)")
        print(f"Modulation frequency: {fm/1e9:.1f} GHz")
        print(f"Sampling frequency: {self.fs/1e9:.1f} GHz")
        print(f"Time samples: {len(self.t)}")
        print(f"Duration: {duration*1e9:.1f} ns")
        print(f"Frequency resolution: {self.fs/len(self.t)/1e6:.2f} MHz\n")
    
    def single_tone_bessel_expansion(self, beta, omega_mod, phi, max_order=5):
        """
        Bessel expansion with limited order for clarity
        """
        print(f"Computing Bessel expansion:")
        print(f"  Modulation depth β = {beta:.3f} rad")
        print(f"  Modulation frequency = {omega_mod/(2*np.pi)/1e9:.3f} GHz")
        print(f"  Phase offset φ = {phi:.3f} rad ({phi*180/np.pi:.1f}°)")
        
        modulation_envelope = np.zeros(len(self.t), dtype=complex)
        bessel_coeffs = {}
        
        print(f"\n  Significant Bessel Coefficients J_n({beta:.3f}):")
        for n in range(-max_order, max_order + 1):
            Jn = jv(n, beta)
            bessel_coeffs[n] = Jn
            
            # Add this sideband to the total
            sideband_term = Jn * np.exp(1j * n * (omega_mod * self.t + phi))
            modulation_envelope += sideband_term
            
            if abs(Jn) > 0.001:  # Only print significant coefficients
                print(f"    J_{n:2d} = {Jn:8.5f}")
        
        return modulation_envelope, bessel_coeffs
    
    def three_tone_detailed_analysis(self, beta1, beta2, beta3, phi1, phi2, phi3):
        """
        Three-tone analysis with proper frequency scaling
        """
        print(f"\n=== Three-Tone Modulation Analysis ===")
        
        # Individual modulations with proper frequency relationships
        print("\n1. Tone 1 (fm):")
        mod1, coeffs1 = self.single_tone_bessel_expansion(beta1, self.omega_m, phi1)
        
        print(f"\n2. Tone 2 (2×fm):")
        mod2, coeffs2 = self.single_tone_bessel_expansion(beta2, 2*self.omega_m, phi2)
        
        print(f"\n3. Tone 3 (3×fm):")
        mod3, coeffs3 = self.single_tone_bessel_expansion(beta3, 3*self.omega_m, phi3)
        
        # Combined modulation
        print(f"\n4. Combined Modulation (Product):")
        combined_modulation = mod1 * mod2 * mod3
        
        return combined_modulation, (coeffs1, coeffs2, coeffs3)
    
    def mzm_interference_detailed(self, beta1, beta2, beta3, phi1, phi2, phi3, delta_phi):
        """
        Detailed MZM interference with proper baseband analysis
        """
        print(f"\n{'='*60}")
        print(f"MZM INTERFERENCE DETAILED ANALYSIS")
        print(f"{'='*60}")
        
        # Step 1: Generate baseband carrier (for visualization)
        print(f"\nSTEP 1: Baseband Carrier")
        print(f"Using baseband analysis (carrier at {self.fc_baseband} Hz)")
        
        E0 = 1.0
        if self.fc_baseband == 0:
            carrier = E0 * np.ones(len(self.t), dtype=complex)  # DC for baseband
        else:
            carrier = E0 * np.exp(1j * self.omega_c * self.t)
        
        # Step 2: Generate modulation
        print(f"\nSTEP 2: Modulation Generation")
        modulation_envelope, bessel_data = self.three_tone_detailed_analysis(
            beta1, beta2, beta3, phi1, phi2, phi3
        )
        
        # Step 3: Upper arm
        print(f"\nSTEP 3: Upper Arm Signal")
        upper_arm = (E0/2) * carrier * modulation_envelope
        upper_power = np.mean(np.abs(upper_arm)**2)
        print(f"Upper arm average power: {upper_power:.6f}")
        
        # Step 4: Lower arm with phase shift
        print(f"\nSTEP 4: Lower Arm Signal")
        print(f"Phase shift: Δφ = {delta_phi:.3f} rad = {delta_phi*180/np.pi:.1f}°")
        
        phase_shift_factor = np.exp(1j * delta_phi)
        lower_arm = (E0/2) * carrier * modulation_envelope * phase_shift_factor
        lower_power = np.mean(np.abs(lower_arm)**2)
        
        print(f"Lower arm average power: {lower_power:.6f}")
        print(f"Phase shift factor: {phase_shift_factor:.3f}")
        
        # Step 5: Interference
        print(f"\nSTEP 5: Interference")
        output_signal = upper_arm + lower_arm
        
        interference_factor = 1 + phase_shift_factor
        print(f"Interference factor: {interference_factor:.3f}")
        print(f"Interference magnitude: {abs(interference_factor):.3f}")
        
        output_power = np.mean(np.abs(output_signal)**2)
        input_power = np.mean(np.abs(carrier)**2)
        
        print(f"\nPower Analysis:")
        print(f"Input power: {input_power:.6f}")
        print(f"Output power: {output_power:.6f}")
        print(f"Power gain: {output_power/input_power:.3f}")
        print(f"Power gain (dB): {10*np.log10(output_power/input_power):.2f} dB")
        
        return output_signal, upper_arm, lower_arm, bessel_data
    
    def frequency_domain_analysis(self, signal, title="Signal"):
        """
        Improved frequency domain analysis with proper scaling
        """
        print(f"\n=== Frequency Domain Analysis: {title} ===")
        
        # Compute FFT
        fft_signal = fft.fft(signal)
        frequencies = fft.fftfreq(len(signal), 1/self.fs)
        
        # Get magnitude and phase
        magnitude = np.abs(fft_signal)
        phase = np.angle(fft_signal)
        
        # For baseband analysis, look at both positive and negative frequencies
        freq_range = self.fm * 6  # ±6×fm range
        freq_mask = np.abs(frequencies) <= freq_range
        
        freq_plot = frequencies[freq_mask]
        mag_plot = magnitude[freq_mask]
        phase_plot = phase[freq_mask]
        
        # Find peaks and analyze
        print(f"Frequency components (within ±{freq_range/1e9:.1f} GHz):")
        
        # Expected frequencies for baseband analysis
        expected_freqs = [0, self.fm, 2*self.fm, 3*self.fm, -self.fm, -2*self.fm, -3*self.fm]
        
        for freq_expected in expected_freqs:
            if abs(freq_expected) <= freq_range:
                freq_idx = np.argmin(np.abs(freq_plot - freq_expected))
                mag_val = mag_plot[freq_idx]
                phase_val = phase_plot[freq_idx]
                
                freq_offset = freq_expected / self.fm
                print(f"  {freq_offset:+.0f}×fm ({freq_expected/1e9:+.3f} GHz): "
                      f"Mag = {mag_val:.4f}, Phase = {phase_val*180/np.pi:+6.1f}°")
        
        return freq_plot, mag_plot, phase_plot
    
    def plot_comprehensive_analysis(self, output_signal, upper_arm, lower_arm):
        """
        Improved visualization with proper scaling and readable plots
        """
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        
        # Time domain - use nanoseconds for readability
        time_ns = self.t * 1e9
        
        # Decimate data if too many points for clear visualization
        if len(time_ns) > 1000:
            step = len(time_ns) // 1000
            time_plot = time_ns[::step]
            upper_plot = upper_arm[::step]
            lower_plot = lower_arm[::step] 
            output_plot = output_signal[::step]
        else:
            time_plot = time_ns
            upper_plot = upper_arm
            lower_plot = lower_arm
            output_plot = output_signal
        
        # Upper arm time domain
        axes[0,0].plot(time_plot, np.real(upper_plot), 'b-', linewidth=1.5, label='Real')
        axes[0,0].plot(time_plot, np.imag(upper_plot), 'r--', linewidth=1.5, label='Imag')
        axes[0,0].set_title('Upper Arm Signal', fontsize=14)
        axes[0,0].set_xlabel('Time (ns)')
        axes[0,0].set_ylabel('Amplitude')
        axes[0,0].legend()
        axes[0,0].grid(True, alpha=0.3)
        
        # Lower arm time domain
        axes[0,1].plot(time_plot, np.real(lower_plot), 'b-', linewidth=1.5, label='Real')
        axes[0,1].plot(time_plot, np.imag(lower_plot), 'r--', linewidth=1.5, label='Imag')
        axes[0,1].set_title('Lower Arm Signal', fontsize=14)
        axes[0,1].set_xlabel('Time (ns)')
        axes[0,1].set_ylabel('Amplitude')
        axes[0,1].legend()
        axes[0,1].grid(True, alpha=0.3)
        
        # Output time domain
        axes[0,2].plot(time_plot, np.real(output_plot), 'g-', linewidth=2, label='Real')
        axes[0,2].plot(time_plot, np.imag(output_plot), 'm--', linewidth=2, label='Imag')
        axes[0,2].set_title('Output Signal', fontsize=14, fontweight='bold')
        axes[0,2].set_xlabel('Time (ns)')
        axes[0,2].set_ylabel('Amplitude')
        axes[0,2].legend()
        axes[0,2].grid(True, alpha=0.3)
        
        # Frequency domain analysis
        freq_out, mag_out, phase_out = self.frequency_domain_analysis(output_signal)
        freq_upper, mag_upper, phase_upper = self.frequency_domain_analysis(upper_arm)
        freq_lower, mag_lower, phase_lower = self.frequency_domain_analysis(lower_arm)
        
        # Plot frequency spectra
        axes[1,0].semilogy(freq_upper/self.fm, mag_upper, 'b-', linewidth=2, label='Upper Arm')
        axes[1,0].semilogy(freq_lower/self.fm, mag_lower, 'r--', linewidth=2, label='Lower Arm')
        axes[1,0].set_title('Magnitude Spectra Comparison', fontsize=14)
        axes[1,0].set_xlabel('Frequency Offset (×fm)')
        axes[1,0].set_ylabel('Magnitude')
        axes[1,0].legend()
        axes[1,0].grid(True, alpha=0.3)
        axes[1,0].set_xlim([-4, 4])
        
        # Output magnitude spectrum
        axes[1,1].semilogy(freq_out/self.fm, mag_out, 'g-', linewidth=3)
        axes[1,1].set_title('Output Magnitude Spectrum', fontsize=14, fontweight='bold')
        axes[1,1].set_xlabel('Frequency Offset (×fm)')
        axes[1,1].set_ylabel('Magnitude')
        axes[1,1].grid(True, alpha=0.3)
        axes[1,1].set_xlim([-4, 4])
        
        # Mark important frequencies
        for i in range(-3, 4):
            axes[1,1].axvline(x=i, color='red', linestyle=':', alpha=0.5)
        
        # Output phase spectrum
        axes[1,2].plot(freq_out/self.fm, phase_out*180/np.pi, 'g-', linewidth=3)
        axes[1,2].set_title('Output Phase Spectrum', fontsize=14, fontweight='bold')
        axes[1,2].set_xlabel('Frequency Offset (×fm)')
        axes[1,2].set_ylabel('Phase (degrees)')
        axes[1,2].grid(True, alpha=0.3)
        axes[1,2].set_xlim([-4, 4])
        
        plt.tight_layout()
        plt.show()
        
        return freq_out, mag_out, phase_out

# Demonstration with fixed parameters
if __name__ == "__main__":
    print("=== FIXED MZM ANALYSIS DEMONSTRATION ===\n")
    
    # Create analyzer with baseband analysis for clear visualization
    analyzer = MZMAnalyzer(
        fc_baseband=0,     # Baseband analysis (no carrier for clarity)
        fm=1e9,            # 1 GHz modulation
        fs=20e9,           # 20 GHz sampling (adequate resolution)
        duration=5e-9      # 5 ns duration (5 modulation cycles)
    )
    
    # Realistic modulation parameters
    beta1 = 1.2    # Stronger modulation for visible sidebands
    beta2 = 0.8    
    beta3 = 0.5    
    phi1 = 0.0     
    phi2 = np.pi/3   # 60°
    phi3 = np.pi/2   # 90°
    delta_phi = np.pi/4  # 45° phase shift
    
    print(f"SIMULATION PARAMETERS:")
    print(f"β₁ = {beta1:.1f} rad, φ₁ = {phi1*180/np.pi:.0f}°")
    print(f"β₂ = {beta2:.1f} rad, φ₂ = {phi2*180/np.pi:.0f}°") 
    print(f"β₃ = {beta3:.1f} rad, φ₃ = {phi3*180/np.pi:.0f}°")
    print(f"Δφ = {delta_phi:.3f} rad = {delta_phi*180/np.pi:.0f}°")
    
    # Perform analysis
    output, upper, lower, bessel_data = analyzer.mzm_interference_detailed(
        beta1, beta2, beta3, phi1, phi2, phi3, delta_phi
    )
    
    # Create visualization
    freq_data, mag_data, phase_data = analyzer.plot_comprehensive_analysis(output, upper, lower)
    
    # Additional analysis
    print(f"\n=== SUMMARY ANALYSIS ===")
    print(f"Signal duration: {analyzer.duration*1e9:.1f} ns")
    print(f"Modulation cycles: {analyzer.duration * analyzer.fm:.1f}")
    print(f"Max output amplitude: {np.max(np.abs(output)):.3f}")
    print(f"RMS output amplitude: {np.sqrt(np.mean(np.abs(output)**2)):.3f}")
    
    print(f"\n{'='*60}")
    print(f"FIXED ANALYSIS COMPLETE - PLOTS SHOULD NOW BE READABLE!")
    print(f"{'='*60}")

