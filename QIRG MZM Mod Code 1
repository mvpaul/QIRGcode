import numpy as np
import matplotlib.pyplot as plt
from scipy.special import jv  # Bessel function of the first kind
import pandas as pd
from collections import defaultdict

class MZMSimulator:
    """
    Mach-Zehnder Modulator Simulation with Complex Coefficient Analysis
    """
    
    def __init__(self):
        # Define fundamental parameters
        self.fc = 1.0  # Carrier frequency (normalized)
        self.fm = 0.1  # Modulation frequency spacing
        self.omega1 = self.fm  # First modulation frequency
        self.omega2 = 2 * self.fm  # Second modulation frequency
        self.omega3 = 3 * self.fm  # Third modulation frequency
        
        # Six independent beta parameters - three for each arm
        self.betaU1 = 0.5  # Upper arm, first tone modulation depth
        self.betaU2 = 0.3  # Upper arm, second tone modulation depth
        self.betaU3 = 0.2  # Upper arm, third tone modulation depth
        self.betaL1 = 0.4  # Lower arm, first tone modulation depth
        self.betaL2 = 0.6  # Lower arm, second tone modulation depth
        self.betaL3 = 0.3  # Lower arm, third tone modulation depth
        
        # Phase offsets for each modulation tone
        self.phi1 = 0  # Phase of first modulation tone
        self.phi2 = np.pi/3  # Phase of second modulation tone
        self.phi3 = np.pi/2  # Phase of third modulation tone
        
        # Additional phase shift in lower arm (from phase shifter block)
        self.delta_phase = np.pi/4  # Phase shift between arms
        
        # Input field amplitude
        self.E0 = 1.0  # Input field amplitude
        
        # Maximum Bessel order for computation
        self.max_order = 8
        
        # Initialize coefficients
        self.coeffs_upper = {}
        self.coeffs_lower = {}
        self.combined_coeffs = {}
        
    def calculate_coefficients(self, beta_vec, phase_vec, delta_phase_arm):
        """
        Calculate complex coefficients C_nmk for each arm
        
        Parameters:
        beta_vec: [beta1, beta2, beta3] - modulation depths
        phase_vec: [phi1, phi2, phi3] - phase offsets
        delta_phase_arm: additional phase shift for this arm
        
        Returns:
        Dictionary of coefficients indexed by (n, m, k)
        """
        coeffs = {}
        beta1, beta2, beta3 = beta_vec
        phi1, phi2, phi3 = phase_vec
        
        for n in range(-self.max_order, self.max_order + 1):
            for m in range(-self.max_order, self.max_order + 1):
                for k in range(-self.max_order, self.max_order + 1):
                    # Calculate C_nmk using Bessel functions and phase terms
                    bessel_product = jv(n, beta1) * jv(m, beta2) * jv(k, beta3)
                    phase_term = np.exp(1j * (n*phi1 + m*phi2 + k*phi3 + delta_phase_arm))
                    
                    coeffs[(n, m, k)] = (self.E0/2) * bessel_product * phase_term
                    
        return coeffs
    
    def generate_arm_field(self, coeffs, t):
        """
        Generate the complete field for one arm
        
        Parameters:
        coeffs: Dictionary of complex coefficients
        t: Time array
        
        Returns:
        Complex field array
        """
        field = np.zeros_like(t, dtype=complex)
        
        for n in range(-self.max_order, self.max_order + 1):
            for m in range(-self.max_order, self.max_order + 1):
                for k in range(-self.max_order, self.max_order + 1):
                    freq = self.fc + n*self.omega1 + m*self.omega2 + k*self.omega3
                    coeff = coeffs[(n, m, k)]
                    
                    # Add both positive and negative frequency components
                    field += coeff * np.exp(1j * 2 * np.pi * freq * t)
                    field += np.conj(coeff) * np.exp(-1j * 2 * np.pi * freq * t)
                    
        return field
    
    def field_upper(self, t):
        """Upper arm field"""
        return self.generate_arm_field(self.coeffs_upper, t)
    
    def field_lower(self, t):
        """Lower arm field"""
        return self.generate_arm_field(self.coeffs_lower, t)
    
    def total_field(self, t):
        """Total combined field after MZM interference"""
        return self.field_upper(t) + self.field_lower(t)
    
    def calculate_combined_coefficients(self):
        """Calculate combined coefficients after interference"""
        combined = {}
        for n in range(-self.max_order, self.max_order + 1):
            for m in range(-self.max_order, self.max_order + 1):
                for k in range(-self.max_order, self.max_order + 1):
                    combined[(n, m, k)] = (self.coeffs_upper[(n, m, k)] + 
                                         self.coeffs_lower[(n, m, k)])
        return combined
    
    def extract_spectral_data(self, amplitude_threshold=0.001):
        """
        Extract all frequency components and their properties
        
        Parameters:
        amplitude_threshold: Minimum amplitude to include in results
        
        Returns:
        List of [frequency, amplitude, phase, n, m, k] for each component
        """
        spectral_data = []
        
        for n in range(-self.max_order, self.max_order + 1):
            for m in range(-self.max_order, self.max_order + 1):
                for k in range(-self.max_order, self.max_order + 1):
                    freq = self.fc + n*self.omega1 + m*self.omega2 + k*self.omega3
                    coeff = self.combined_coeffs[(n, m, k)]
                    amplitude = abs(coeff)
                    phase = np.angle(coeff)
                    
                    # Only include components with significant amplitude
                    if amplitude > amplitude_threshold:
                        spectral_data.append([freq, amplitude, phase, n, m, k])
        
        # Sort by frequency
        spectral_data.sort(key=lambda x: x[0])
        return spectral_data
    
    def run_simulation(self):
        """Run the complete MZM simulation"""
        # Calculate coefficients for both arms
        self.coeffs_upper = self.calculate_coefficients(
            [self.betaU1, self.betaU2, self.betaU3],
            [self.phi1, self.phi2, self.phi3],
            0  # No additional phase shift for upper arm
        )
        
        self.coeffs_lower = self.calculate_coefficients(
            [self.betaL1, self.betaL2, self.betaL3],
            [self.phi1, self.phi2, self.phi3],
            self.delta_phase  # Additional phase shift for lower arm
        )
        
        # Calculate combined coefficients after interference
        self.combined_coeffs = self.calculate_combined_coefficients()
        
        # Extract spectral data
        spectral_data = self.extract_spectral_data()
        
        return spectral_data
    
    def create_spectral_plots(self, spectral_data):
        """
        Create comprehensive spectral plots with vertical lines
        """
        if not spectral_data:
            print("No spectral data to plot")
            return
            
        freqs = [data[0] for data in spectral_data]
        amps = [data[1] for data in spectral_data]
        phases = [data[2] for data in spectral_data]
        
        # Create figure with two subplots
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
        
        # Amplitude spectrum with vertical lines
        for i, (freq, amp) in enumerate(zip(freqs, amps)):
            ax1.plot([freq, freq], [0, amp], 'r-', linewidth=2)
        
        ax1.set_xlabel('Frequency (normalized)')
        ax1.set_ylabel('Amplitude')
        ax1.set_title('Amplitude Spectrum After MZM')
        ax1.grid(True, alpha=0.3)
        ax1.set_xlim(min(freqs) - 0.1, max(freqs) + 0.1)
        ax1.set_ylim(0, max(amps) * 1.1)
        
        # Phase spectrum with vertical lines
        for i, (freq, phase) in enumerate(zip(freqs, phases)):
            ax2.plot([freq, freq], [0, phase], 'b-', linewidth=2)
        
        ax2.set_xlabel('Frequency (normalized)')
        ax2.set_ylabel('Phase (radians)')
        ax2.set_title('Phase Spectrum After MZM')
        ax2.grid(True, alpha=0.3)
        ax2.set_xlim(min(freqs) - 0.1, max(freqs) + 0.1)
        ax2.set_ylim(-np.pi, np.pi)
        
        plt.tight_layout()
        plt.show()
        
        return fig
    
    def analyze_target_frequencies(self, target_freqs, spectral_data, tolerance=0.01):
        """
        Analyze specific target frequencies
        
        Parameters:
        target_freqs: List of target frequencies to analyze
        spectral_data: Output from extract_spectral_data()
        tolerance: Frequency matching tolerance
        
        Returns:
        List of results for each target frequency
        """
        results = []
        
        for target_freq in target_freqs:
            closest_match = None
            min_diff = float('inf')
            
            for data in spectral_data:
                diff = abs(data[0] - target_freq)
                if diff < min_diff:
                    min_diff = diff
                    closest_match = data
            
            if min_diff < tolerance and closest_match:
                results.append([target_freq, closest_match[1], closest_match[2], 
                              closest_match[3], closest_match[4], closest_match[5]])
            else:
                results.append([target_freq, 0, 0, 0, 0, 0])  # No match found
                
        return results
    
    def time_analysis(self, t_max=20, num_points=500):
        """
        Time domain analysis of the combined MZM output
        
        Parameters:
        t_max: Maximum time for analysis
        num_points: Number of time points
        
        Returns:
        Time array and field values
        """
        t = np.linspace(0, t_max, num_points)
        field_values = self.total_field(t)
        
        # Create time domain plot
        fig, ax = plt.subplots(figsize=(12, 6))
        
        ax.plot(t, np.real(field_values), 'r-', label='Real', linewidth=1.5)
        ax.plot(t, np.imag(field_values), 'b-', label='Imaginary', linewidth=1.5)
        ax.plot(t, np.abs(field_values), 'k-', label='Amplitude', linewidth=1.5)
        
        ax.set_xlabel('Time')
        ax.set_ylabel('Field')
        ax.set_title('Time Domain Response of Combined MZM Output')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
        return t, field_values
    
    def print_spectral_table(self, spectral_data):
        """Print spectral components in a formatted table"""
        print("\nSpectral Components After MZM Interference:")
        print("Frequency = fc + n*ω1 + m*ω2 + k*ω3")
        print()
        
        # Create DataFrame for nice formatting
        df = pd.DataFrame(spectral_data, 
                         columns=['Frequency', 'Amplitude', 'Phase (rad)', 'n', 'm', 'k'])
        
        # Format numerical columns
        df['Frequency'] = df['Frequency'].round(3)
        df['Amplitude'] = df['Amplitude'].round(4)
        df['Phase (rad)'] = df['Phase (rad)'].round(3)
        
        print(df.to_string(index=False))
        
    def print_target_analysis(self, target_results):
        """Print analysis of target frequencies"""
        print("\nAnalysis of Target Frequencies:")
        
        df = pd.DataFrame(target_results,
                         columns=['Target Freq', 'Amplitude', 'Phase (rad)', 'n', 'm', 'k'])
        
        # Format numerical columns
        df['Target Freq'] = df['Target Freq'].round(3)
        df['Amplitude'] = df['Amplitude'].round(4)
        df['Phase (rad)'] = df['Phase (rad)'].round(3)
        
        print(df.to_string(index=False))

# Example usage and simulation
def main():
    # Create MZM simulator
    mzm = MZMSimulator()
    
    # Run simulation
    print("Running MZM Simulation...")
    spectral_data = mzm.run_simulation()
    
    # Print spectral table
    mzm.print_spectral_table(spectral_data)
    
    # Analyze specific target frequencies
    target_freqs = [mzm.fc, mzm.fc + mzm.fm, mzm.fc + 2*mzm.fm, mzm.fc + 3*mzm.fm]  # wc, w1, w2, w3
    target_results = mzm.analyze_target_frequencies(target_freqs, spectral_data)
    mzm.print_target_analysis(target_results)
    
    # Create spectral plots
    print("\nGenerating spectral plots...")
    mzm.create_spectral_plots(spectral_data)
    
    # Time domain analysis
    print("\nGenerating time domain analysis...")
    t, field_values = mzm.time_analysis()
    
    # Example of parameter modification
    print("\nExample: Modifying parameters...")
    mzm.betaU1 = 1.84  # First zero of J_0 to suppress carrier
    mzm.delta_phase = np.pi/2  # Quarter-wave phase shift
    
    # Re-run with new parameters
    spectral_data_new = mzm.run_simulation()
    print("\nWith modified parameters:")
    mzm.print_spectral_table(spectral_data_new[:10])  # Show first 10 components
    
if __name__ == "__main__":
    main()