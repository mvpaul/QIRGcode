import numpy as np
import matplotlib.pyplot as plt
from scipy.special import jv
from scipy.optimize import minimize
import scipy.fft as fft

class MZMFocusedOptimizer:
    """
    Focused MZM Optimizer - Clean comparison with amplitude and phase
    """
    
    def __init__(self, fm=1e9, duration_cycles=16):
        """Initialize optimizer"""
        self.fm = fm
        self.omega_m = 2 * np.pi * fm
        
        self.duration = duration_cycles / fm
        self.fs = 64 * fm
        self.num_samples = int(duration_cycles * self.fs / fm)
        self.duration = self.num_samples / self.fs
        self.t = np.linspace(0, self.duration, self.num_samples, endpoint=False)
        
        print(f"=== MZM Focused Sideband Optimizer ===")
        print(f"Target: Enhance 0×fm, +1×fm, +2×fm, +3×fm")
        print(f"Suppress: All other sidebands")
        
    def generate_modulated_signal(self, beta1, beta2, beta3, phi1, phi2, phi3):
        """Generate modulated signal"""
        max_order = 4
        signal = np.zeros(len(self.t), dtype=complex)
        
        for n1 in range(-max_order, max_order + 1):
            for n2 in range(-max_order, max_order + 1):
                for n3 in range(-max_order, max_order + 1):
                    freq_offset = n1 + 2*n2 + 3*n3
                    
                    if abs(freq_offset) <= 8:
                        amplitude = jv(n1, beta1) * jv(n2, beta2) * jv(n3, beta3)
                        
                        if abs(amplitude) > 1e-6:
                            phase = n1*phi1 + n2*phi2 + n3*phi3
                            signal += amplitude * np.exp(1j * (freq_offset * self.omega_m * self.t + phase))
        
        return signal
    
    def mzm_output(self, params):
        """Generate MZM output"""
        beta1, beta2, beta3, phi1, phi2, phi3, delta_phi = params
        
        modulation = self.generate_modulated_signal(beta1, beta2, beta3, phi1, phi2, phi3)
        
        upper_arm = 0.5 * modulation
        lower_arm = 0.5 * modulation * np.exp(1j * delta_phi)
        output = upper_arm + lower_arm
        
        return output
    
    def extract_frequency_components(self, signal):
        """Extract amplitude and phase at each frequency"""
        fft_signal = fft.fft(signal)
        frequencies = fft.fftfreq(self.num_samples, 1/self.fs)
        
        components = {}
        for order in range(-6, 7):  # Check -6 to +6 fm
            target_freq = order * self.fm
            freq_idx = np.argmin(np.abs(frequencies - target_freq))
            
            if abs(frequencies[freq_idx] - target_freq) < self.fm / 50:
                complex_val = fft_signal[freq_idx]
                amplitude = abs(complex_val)
                phase = np.angle(complex_val) * 180 / np.pi  # Convert to degrees
                
                if amplitude > 1e-6:
                    components[order] = {
                        'amplitude': amplitude,
                        'phase': phase,
                        'complex': complex_val
                    }
        
        return components
    
    def sideband_shaping_objective(self, params):
        """Objective function for optimization"""
        try:
            output = self.mzm_output(params)
            components = self.extract_frequency_components(output)
            
            # Target sidebands to enhance
            target_sidebands = [0, 1, 2, 3]
            target_power = sum(components.get(sb, {'amplitude': 0})['amplitude']**2 
                             for sb in target_sidebands)
            
            # Unwanted sidebands to suppress
            suppress_sidebands = [-6, -5, -4, -3, -2, -1, 4, 5, 6]
            suppress_power = sum(components.get(sb, {'amplitude': 0})['amplitude']**2 
                               for sb in suppress_sidebands)
            
            # Objective: minimize ratio of unwanted to wanted power
            if target_power > 1e-12:
                objective = suppress_power / target_power
            else:
                objective = 1e6
            
            return objective
            
        except:
            return 1e6
    
    def optimize_sidebands(self, initial_params):
        """Run optimization"""
        print(f"\n=== Starting Optimization ===")
        
        bounds = [
            (0.1, 3.0),      # beta1
            (0.1, 3.0),      # beta2
            (0.1, 3.0),      # beta3
            (0, 2*np.pi),    # phi1
            (0, 2*np.pi),    # phi2
            (0, 2*np.pi),    # phi3
            (0, 2*np.pi),    # delta_phi
        ]
        
        result = minimize(
            self.sideband_shaping_objective,
            initial_params,
            method='L-BFGS-B',
            bounds=bounds,
            options={'maxiter': 500, 'disp': True}
        )
        
        print(f"Optimization success: {result.success}")
        print(f"Final objective: {result.fun:.6f}")
        
        return result
    
    def plot_focused_comparison(self, original_params, optimized_params):
        """
        Create focused comparison plot with amplitude and phase information
        """
        # Generate signals
        output_original = self.mzm_output(original_params)
        output_optimized = self.mzm_output(optimized_params)
        
        # Extract components
        comp_original = self.extract_frequency_components(output_original)
        comp_optimized = self.extract_frequency_components(output_optimized)
        
        # Create single comparison plot
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 8))
        fig.suptitle('MZM Sideband Optimization: Before vs After (with Phases)', 
                     fontsize=16, fontweight='bold')
        
        # Plot original spectrum
        self.plot_spectrum_with_phases(ax1, comp_original, 
                                     'Original Spectrum', 'blue')
        
        # Plot optimized spectrum
        self.plot_spectrum_with_phases(ax2, comp_optimized, 
                                     'Optimized Spectrum', 'green')
        
        plt.tight_layout()
        plt.show()
        
        # Print focused numerical comparison
        self.print_focused_comparison(comp_original, comp_optimized)
        
        return fig
    
    def plot_spectrum_with_phases(self, ax, components, title, color):
        """
        Plot spectrum bars with amplitude and phase labels
        Focus only on frequencies we care about
        """
        if not components:
            ax.text(0.5, 0.5, 'No components', ha='center', va='center', transform=ax.transAxes)
            ax.set_title(title, fontweight='bold')
            return
        
        # Focus on frequency range -3 to +5 fm
        freq_range = range(-3, 6)
        orders = [f for f in freq_range if f in components]
        
        if not orders:
            ax.text(0.5, 0.5, 'No significant components in range', 
                   ha='center', va='center', transform=ax.transAxes)
            ax.set_title(title, fontweight='bold')
            return
        
        amplitudes = [components[f]['amplitude'] for f in orders]
        phases = [components[f]['phase'] for f in orders]
        
        # Create bars
        x_pos = np.arange(len(orders))
        bars = ax.bar(x_pos, amplitudes, alpha=0.8, edgecolor='black', linewidth=1)
        
        # Color coding
        target_sidebands = [0, 1, 2, 3]
        for i, order in enumerate(orders):
            if order in target_sidebands:
                bars[i].set_color('red')       # Target sidebands in red
                bars[i].set_alpha(0.9)
                bars[i].set_linewidth(2)
            elif order < 0:
                bars[i].set_color('orange')    # Negative sidebands in orange
                bars[i].set_alpha(0.7)
            else:
                bars[i].set_color(color)       # Other positive sidebands in base color
                bars[i].set_alpha(0.6)
        
        # Add amplitude labels on top of bars
        max_amplitude = max(amplitudes) if amplitudes else 1
        for i, (order, amp) in enumerate(zip(orders, amplitudes)):
            if amp > max_amplitude * 0.01:  # Only label significant components
                ax.text(i, amp + max_amplitude*0.02, f'{amp:.1f}', 
                       ha='center', va='bottom', fontsize=11, fontweight='bold')
        
        # Add phase labels underneath bars (in purple)
        for i, (order, phase) in enumerate(zip(orders, phases)):
            amp = amplitudes[i]
            if amp > max_amplitude * 0.01:  # Only label significant components
                ax.text(i, -max_amplitude*0.12, f'{phase:.0f}°', 
                       ha='center', va='top', fontsize=10, fontweight='bold', 
                       color='purple')
        
        # Formatting
        ax.set_title(title, fontsize=14, fontweight='bold')
        ax.set_xlabel('Frequency Components', fontsize=12, fontweight='bold')
        ax.set_ylabel('Amplitude', fontsize=12, fontweight='bold')
        ax.set_xticks(x_pos)
        ax.set_xticklabels([f'{order:+d}×fm' for order in orders], fontsize=11)
        ax.grid(True, alpha=0.3, axis='y')
        ax.set_ylim(bottom=-max_amplitude*0.2)  # Make room for phase labels
        
        # Add legend
        from matplotlib.patches import Patch
        legend_elements = [
            Patch(facecolor='red', alpha=0.9, label='Target (0,1,2,3×fm)'),
            Patch(facecolor='orange', alpha=0.7, label='Negative sidebands'),
            Patch(facecolor=color, alpha=0.6, label='Other sidebands')
        ]
        ax.legend(handles=legend_elements, loc='upper right', fontsize=10)
        
        # Add phase legend
        ax.text(0.02, 0.02, 'Purple numbers = Phase (degrees)', 
               transform=ax.transAxes, fontsize=10, 
               bbox=dict(boxstyle="round,pad=0.3", facecolor="lightyellow", alpha=0.8))
    
    def print_focused_comparison(self, comp_orig, comp_opt):
        """Print focused numerical comparison"""
        print(f"\n=== Focused Comparison: Key Frequencies ===")
        
        # Target sidebands
        target_sidebands = [0, 1, 2, 3]
        print(f"\nTARGET SIDEBANDS (should maintain similar amplitudes):")
        print(f"{'Freq':<8} {'Original':<15} {'Optimized':<15} {'Change':<10} {'Phase Change'}")
        print(f"{'-'*70}")
        
        for sb in target_sidebands:
            orig_amp = comp_orig.get(sb, {'amplitude': 0, 'phase': 0})['amplitude']
            orig_phase = comp_orig.get(sb, {'amplitude': 0, 'phase': 0})['phase']
            
            opt_amp = comp_opt.get(sb, {'amplitude': 0, 'phase': 0})['amplitude']
            opt_phase = comp_opt.get(sb, {'amplitude': 0, 'phase': 0})['phase']
            
            amp_change = opt_amp / (orig_amp + 1e-12)
            phase_change = opt_phase - orig_phase
            
            print(f"{sb:+2d}×fm   {orig_amp:6.1f} ∠{orig_phase:4.0f}°   "
                  f"{opt_amp:6.1f} ∠{opt_phase:4.0f}°   {amp_change:6.2f}x   {phase_change:+6.0f}°")
        
        # Suppressed sidebands
        suppress_sidebands = [-3, -2, -1, 4, 5]
        print(f"\nSUPPRESSED SIDEBANDS:")
        print(f"{'Freq':<8} {'Original':<15} {'Optimized':<15} {'Suppression'}")
        print(f"{'-'*60}")
        
        for sb in suppress_sidebands:
            if sb in comp_orig or sb in comp_opt:
                orig_amp = comp_orig.get(sb, {'amplitude': 0, 'phase': 0})['amplitude']
                orig_phase = comp_orig.get(sb, {'amplitude': 0, 'phase': 0})['phase']
                
                opt_amp = comp_opt.get(sb, {'amplitude': 0, 'phase': 0})['amplitude']
                opt_phase = comp_opt.get(sb, {'amplitude': 0, 'phase': 0})['phase']
                
                if orig_amp > 1e-6:
                    suppression_db = 20 * np.log10(orig_amp / (opt_amp + 1e-12))
                else:
                    suppression_db = 0
                
                print(f"{sb:+2d}×fm   {orig_amp:6.1f} ∠{orig_phase:4.0f}°   "
                      f"{opt_amp:6.1f} ∠{opt_phase:4.0f}°   {suppression_db:6.1f} dB")
        
        # Overall metrics
        target_power_orig = sum(comp_orig.get(sb, {'amplitude': 0})['amplitude']**2 for sb in target_sidebands)
        target_power_opt = sum(comp_opt.get(sb, {'amplitude': 0})['amplitude']**2 for sb in target_sidebands)
        
        suppress_power_orig = sum(comp_orig.get(sb, {'amplitude': 0})['amplitude']**2 for sb in suppress_sidebands)
        suppress_power_opt = sum(comp_opt.get(sb, {'amplitude': 0})['amplitude']**2 for sb in suppress_sidebands)
        
        ratio_orig = 10 * np.log10((target_power_orig + 1e-12) / (suppress_power_orig + 1e-12))
        ratio_opt = 10 * np.log10((target_power_opt + 1e-12) / (suppress_power_opt + 1e-12))
        
        print(f"\n=== PERFORMANCE SUMMARY ===")
        print(f"Target sideband power: {target_power_orig:.1f} → {target_power_opt:.1f}")
        print(f"Unwanted sideband power: {suppress_power_orig:.1f} → {suppress_power_opt:.1f}")
        print(f"Suppression ratio: {ratio_orig:.1f} dB → {ratio_opt:.1f} dB")
        print(f"Improvement: {ratio_opt - ratio_orig:+.1f} dB")

# Demonstration
if __name__ == "__main__":
    print("=== FOCUSED MZM SIDEBAND OPTIMIZATION ===\n")
    
    # Create optimizer
    optimizer = MZMFocusedOptimizer(fm=1e9, duration_cycles=16)
    
    # Your current parameters (from your plot)
    current_params = [1.0, 0.7, 0.4, 0, np.pi/4, np.pi/2, np.pi/6]
    
    print(f"Current parameters:")
    labels = ['β₁', 'β₂', 'β₃', 'φ₁', 'φ₂', 'φ₃', 'Δφ']
    for label, param in zip(labels, current_params):
        if 'φ' in label or 'Δφ' in label:
            print(f"  {label} = {param:.3f} rad ({param*180/np.pi:.1f}°)")
        else:
            print(f"  {label} = {param:.3f}")
    
    # Run optimization
    result = optimizer.optimize_sidebands(current_params)
    
    if result.success:
        optimized_params = result.x
        
        print(f"\nOptimized parameters:")
        for label, param in zip(labels, optimized_params):
            if 'φ' in label or 'Δφ' in label:
                print(f"  {label} = {param:.3f} rad ({param*180/np.pi:.1f}°)")
            else:
                print(f"  {label} = {param:.3f}")
        
        # Create focused comparison
        print(f"\n=== Creating Focused Comparison ===")
        fig = optimizer.plot_focused_comparison(current_params, optimized_params)
        
        print(f"\n=== OPTIMIZATION COMPLETE ===")
        print(f"✓ Two clean plots: Original vs Optimized")
        print(f"✓ Amplitude bars with numerical labels")
        print(f"✓ Phase values in purple underneath each bar")
        print(f"✓ Color-coded: Red=Target, Orange=Negative, Blue/Green=Others")
        print(f"✓ Focused on frequencies you care about (-3 to +5 fm)")
        
    else:
        print(f"Optimization failed: {result.message}")